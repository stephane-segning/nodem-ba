\chapter{Vorverarbeitung}
\label{ch:vorverarbeitung}

Dieses Kapitel bündelt die Vorverarbeitungsschritte der \ac{LiDAR}-Punktwolken. Ziel ist es, Datenvolumen und Rauschen vor den nachfolgenden Modulen zu reduzieren und gleichzeitig eine gleichmäßig verteilte Datenbasis für Segmentierung und Clustering zu schaffen. Im Zentrum stehen die räumliche Begrenzung per CropBox und die Ausdünnung mittels VoxelGrid, jeweils mit den verwendeten Parametern und der Umsetzung in der \ac{ROS}~2-Verarbeitungskette.

\section{CropBox-Filter}
\label{sec:cropbox}

\subsection{Prinzip}
Der \textit{CropBox-Filter} begrenzt eine Punktwolke auf eine achsenparallel ausgerichtete Begrenzungsbox (Axis-Aligned Bounding Box, AABB) und entfernt sämtliche Punkte außerhalb des Volumens. Formal sei \(\mathcal{P}=\{\mathbf{p}_i\}\) eine Punktwolke mit \(\mathbf{p}_i=[x_i,y_i,z_i,1]^\top\) in homogenen Koordinaten. Der Filter prüft für jede Stichprobe, ob
\begin{align}
\mathbf{b}_\text{min} \leq \mathbf{R}\,\mathbf{p}_i + \mathbf{t} \leq \mathbf{b}_\text{max}
\label{eq:cropbox}
\end{align}
gilt, wobei \(\mathbf{R}\in\mathbb{R}^{3\times4}\) die ersten drei Zeilen der \ac{PCL}-internen Transformationsmatrix sind, \(\mathbf{t}\) eine optionale Translation darstellt und \(\mathbf{b}_\text{min/max}=[x_{\min/\max},y_{\min/\max},z_{\min/\max}]^\top\) die parametrisierte Box definieren. Punkte, die diese Ungleichung nicht erfüllen, werden verworfen. Die Operation besitzt eine lineare Laufzeit \(\mathcal{O}(|\mathcal{P}|)\) und reduziert das Datenvolumen vor nachgelagerten Schritten signifikant (vgl. \cite{rusu2011pcl,pcl_cropbox_2025}). Durch die optionale Transformationsmatrix lassen sich zusätzlich gekippte Sensorkoordinaten oder Fahrzeugversätze berücksichtigen, wodurch die AABB effektiv einer beliebig orientierten Bounding Box im globalen Rahmen entspricht \cite{pcl_docs_2025}.

Die Grenzen wurden schrittweise verengt: Ausgangspunkt war eine großzügige Box \(\mathbf{b}_\text{min}=[-20,-15,-3]^\top\), \(\mathbf{b}_\text{max}=[20,15,5]^\top\), die anschließend entlang \(x\), \(y\) und \(z\) in \(0{,}5\,\mathrm{m}\)-Schritten reduziert wurde. Jede Variante wurde anhand der Detektionspräzision nach dem Clustering, der verbleibenden Punktzahl und des abgeschnittenen Fahrbahnrands in \ac{RViz} bewertet. Dieses iterative \ac{ROI}-Tuning folgt gängigen Empfehlungen zur Falsch-Alarm-Reduktion \cite{hu2013robust,himmelsbach2010fast}. Die finalen Grenzen \(\mathbf{b}_\text{min}=[-10,-6,-3]^\top\) und \(\mathbf{b}_\text{max}=[10,6,5]^\top\) balancieren Datenreduktion und stabile Objektabdeckung im urbanen Messfeld.

\subsection{Implementierung}
Der \texttt{crop\_box\_node} wurde in C++ unter \ac{ROS}~2 umgesetzt und nutzt die \ac{PCL}-Schnittstellen, um die Ungleichung aus Gleichung~\eqref{eq:cropbox} Punkt für Punkt anzuwenden. Der Node abonniert \texttt{/ouster/points} mit SensorDataQoS, lädt die Grenzen \texttt{min\_bound} und \texttt{max\_bound} sowie die Topics \texttt{input\_topic} und \texttt{output\_topic} und publiziert das Ergebnis auf \texttt{/points\_cropped}. Tabelle~\ref{tab:cropbox_params} fasst das Parameter-Set zusammen; der produktive Code unter \texttt{ouster\_cpp/src/crop\_box\_node.cpp} ist in Anhang vollständig abgedruckt.

\begin{verbatim}
// Ausschnitt aus src/ouster_cpp/src/crop_box_node.cpp
const float xmin = min_bound_[0], xmax = max_bound_[0];
const float ymin = min_bound_[1], ymax = max_bound_[1];
const float zmin = min_bound_[2], zmax = max_bound_[2];

for (; ix != ix.end(); ++ix, ++iy, ++iz) {
  const float x = *ix, y = *iy, z = *iz;
  // AABB-Test
  if (x >= xmin && x <= xmax &&
      y >= ymin && y <= ymax &&
      z >= zmin && z <= zmax) {
    // Punkt in Ausgabepuffer übernehmen
  }
}
\end{verbatim}

Neben den Pflichtfeldern \(x,y,z\) unterstützt der Node optionale Felder (\texttt{intensity}, \texttt{ring}) und erlaubt über die Callback-API \texttt{add\_on\_set\_parameters\_callback} eine Laufzeitänderung der Grenzen ohne Neustart des Nodes. Tabelle~\ref{tab:cropbox_params} fasst die Startparameter zusammen.

\begin{table}[H]
  \centering
  \begin{tabular}{|l|c|}
    \hline
    \textbf{Parametername} & \textbf{Startwert} \\ \hline
    \texttt{input\_topic}  & \texttt{/ouster/points} \\ \hline
    \texttt{output\_topic} & \texttt{/points\_cropped} \\ \hline
    \texttt{min\_bound}    & \([-20.0, -15.0, -3.0]\) \\ \hline
    \texttt{max\_bound}    & \([20.0, 15.0, 5.0]\) \\ \hline
  \end{tabular}
  \caption{Startparameter des CropBox-Filters}
  \label{tab:cropbox_params}
\end{table}

Das Zuschneidevolumen bezieht sich auf das Sensorkoordinatensystem des Ouster-LiDARs und folgt der in \ac{ROS} etablierten Konvention nach REP~103: \(x\) zeigt in Fahrtrichtung, \(y\) nach links und \(z\) nach oben; der Ursprung liegt im \ac{LiDAR}-Frame auf Fahrzeughöhe. Der Node unterstützt Pflichtfelder (\texttt{x}, \texttt{y}, \texttt{z}) sowie optionale Attribute wie \texttt{intensity} (FLOAT32/UINT16) und \texttt{ring}. Für jeden Punkt wird geprüft, ob er innerhalb der parametrierten Box liegt; bei Erfolg wird er übernommen. Über \texttt{set\_parameters} lassen sich die Grenzen zur Laufzeit anpassen, ohne die \ac{ROS}~2-Verbindungen neu aufzubauen.

\subsection{Test und Ergebnis}
Die Wirkung des CropBox-Filters wird nicht allein über Visualisierungen überprüft, sondern durch eine
schrittweise Verifikation. Dafür wird das aufgezeichnete \ac{ROS}~2-Bag einer T-Kreuzung auf ebenem Asphaltboden
(bewusst gewählt, um symmetrische Sichtfelder und eine klare Bodenreferenz zu erhalten) mehrfach wiedergegeben.
Pro Wiederholung werden drei Messgrößen protokolliert: (1) die Zahl der Eingangspunkte, (2) die Zahl der
beibehaltenen Punkte innerhalb der AABB sowie (3) die zeitliche Stempelverschiebung zwischen Eingangs- und
Ausgangsnachricht als Indikator der Knotendauer. Ein Skript fasst die Ergebnisse als CSV zusammen und
ermöglicht den Vergleich verschiedener Parameterkombinationen.

Das Testszenario „Kreuzung auf ebenem Boden“ ist gewählt, weil es sowohl freie Sichtflächen als auch klar
begrenzte Hindernisse (Randbebauung, Bordsteine) bietet und damit typische urbanen Einsatzbedingungen
repräsentiert, ohne dass Bodenunebenheiten die Filterbewertung verfälschen. In der finalen Konfiguration
reduziert der Filter die Punktanzahl reproduzierbar um rund zwei Drittel, während der Zeitstempel im Header sicherstellt, dass nachgelagerte Latenzmessungen den korrekten
Sendezeitpunkt erhalten.
Da sich im Messbereich Gebäude und weitere störende Objekte befanden, welche die Anzahl falscher Detektionen signifikant erhöhen konnten, wurden die Grenzen des \texttt{crop\_box\_node} sukzessive angepasst. Durch iterative Parameteroptimierung ergaben sich folgende final verwendete Werte: \texttt{min\_bound = [-10.0, -6.0, -3.0]} sowie \texttt{max\_bound = [10.0, 6.0, 5.0]}.
Physikalisch orientieren sich diese Grenzen an der Testumgebung: Mit \(\pm10\,\text{m}\)
in \(x\)-Richtung wird der relevante Bereich vor und hinter dem Fahrzeug für Manöver im
innerstädtischen Geschwindigkeitsbereich erfasst, ohne Gebäude an weit entfernten
Fassaden mitzunehmen. \(\pm6\,\text{m}\) in \(y\)-Richtung decken eine Fahrspur sowie
Gegen- oder Parkspur ab (typisch \(3{-}3{,}5\,\text{m}\) je Spur) und schließen Gehwege
ein, während die Vertikalgrenzen von \(-3\,\text{m}\) bis \(5\,\text{m}\) sowohl den
Fahrbahnbereich unterhalb des Sensors als auch überhängende Objekte wie Lkw-Aufbauten
oder niedrige Brücken berücksichtigen.

Abbildung~\ref{fig:cropbox_compare} zeigt die Wirkung des Filters im Vergleich:
Links ist die ursprüngliche Punktwolke mit vollständiger Umgebung dargestellt,
während rechts nur der relevante Bereich nach Anwendung des CropBox-Filters zu sehen ist. 

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{Bilder/cropbox_compare.png}
  \caption{Vergleich der Punktwolke vor (links) und nach (rechts) Anwendung des 
  \textit{CropBox-Filters} (2025-10-15-Messdaten/2025-10-15-VK-OL-005).}
  \label{fig:cropbox_compare}
\end{figure}


\section{VoxelGrid-Filter}
\label{sec:voxelgrid}

\subsection{Prinzip}\label{subsec:prinzip}
Der \textit{VoxelGrid-Filter} reduziert die Punktanzahl, indem der Raum in kubische Voxel der
Kantenlänge $l=\texttt{voxel\_size}$ diskretisiert wird und pro Voxel nur ein repräsentativer Punkt
(z.\,B. der erste oder ein Schwerpunkt) beibehalten wird. Dadurch sinken Datenrate und
Rechenaufwand nachgelagerter Schritte (Bodenebensegmentierung, Clustering, Tracking), bei
gleichzeitiger Kontrolle des Informationsverlustes über die Wahl von $l$.
Mathematisch erfolgt zunächst eine Quantisierung der Punktkoordinaten $(x,y,z)$ auf ganzzahlige
Gitterindizes $(i,j,k)$ über
\begin{equation}
  (i,j,k) = \left(\left\lfloor \tfrac{x}{l} \right\rfloor, \left\lfloor \tfrac{y}{l} \right\rfloor, \left\lfloor \tfrac{z}{l} \right\rfloor\right),
  \label{eq:voxel_index}
\end{equation}
wodurch alle Punkte innerhalb eines Voxels dieselben Indizes teilen. Für jedes belegte Voxel wird
genau ein Repräsentant behalten. In der vorliegenden Implementierung ist das der erste verarbeitete
Punkt pro Voxel; alternativ könnte der Schwerpunkt
\begin{equation}
  \bar{p}_v = \tfrac{1}{|V|} \sum_{p \in V} p
  \label{eq:voxel_centroid}
\end{equation}
als repräsentativer Punkt gewählt werden. Beide Varianten begrenzen die Anzahl der verbleibenden
Punkte auf höchstens ein Sample pro Voxel und machen den Aufwand proportional zur Anzahl belegter
Voxel. Die Wahl der Voxelkante $l$ steuert damit direkt den Kompromiss zwischen Detailtreue und
Rechenaufwand.

Abbildung~\ref{fig:voxel_principle} veranschaulicht das Funktionsprinzip des VoxelGrid-Filters durch die Aufteilung des Raums in gleichmäßige Voxel.

% préambule : \usepackage{graphicx}
\begin{figure}[H]
  \centering
  \includegraphics[width=.82\textwidth]{Bilder/voxelgrid_prinzip.png}%
  \caption{Funktionsprinzip des VoxelGrid-Filters: Aufteilung des Raums in Voxel und
  Beibehaltung eines repräsentativen Punktes pro Voxel (nach Lyu~u.\,a., 2024).}
  \label{fig:voxel_principle}
\end{figure}


\subsection{Implementierung}
Der \textit{VoxelFilterNode} liest die
zuvor per \textit{CropBox} zugeschnittene Punktwolke auf \texttt{points\_cropped}, setzt in
der \ac{PCL}-Implementierung \texttt{pcl::VoxelGrid<pcl::PointXYZI>} die Blattgröße
\texttt{voxel\_size} in allen drei Achsen und führt anschließend die Unterabtastung aus.
Dadurch wird pro belegtem Voxel exakt ein Punkt in die ausgegebene, unterabgetastete
Punktwolke \texttt{points\_voxel} übernommen; die Rechenkomplexität sinkt damit auf
\(\mathcal{O}(n_\text{voxel})\), was
insbesondere die nachgelagerte k-d-Baum-Suche beim Clustering entlastet. Eine zu große
Voxelkante würde jedoch feine Strukturen (z.\,B. Fahrradspeichen oder dünne Leitpfosten)
verschmieren, während eine zu kleine Kante kaum Rechenzeit spart und die Cluster-Parameter
\(\varepsilon\) anheben würde (vgl. Abschnitt~\ref{chap:clustering}).

Die Startwahl \texttt{voxel\_size} = \SI{0,20}{\meter} orientiert sich sowohl an Literatur als
auch an den Tests aus Kapitel~\ref{chap:test_und_bewertung}. Lyu~u.\,a. \parencite{lyu2024voxel} untersuchen das
Voxel-Downsampling in urbanen Karten und zeigen, dass Blattgrößen im Bereich
\SI{0,15}{\meter}--\SI{0,25}{\meter} das Rauschen signifikant reduzieren, ohne Fußgänger und
Fahrräder zu verlieren; \SI{0,20}{\meter} erweist sich dort als stabiler Kompromiss. Die wichtigsten Startparameter
sind in Tabelle~\ref{tab:voxel_params} zusammengefasst.

% préambule : \usepackage{booktabs} (optionnel, pour un rendu plus pro)
\begin{table}[H]
  \centering
  \begin{tabular}{|l|c|}
    \hline
    \textbf{Parametername} & \textbf{Startwert} \\ \hline
    \texttt{input\_topic}  & \texttt{points\_cropped} \\ \hline
    \texttt{output\_topic} & \texttt{points\_voxel} \\ \hline
    \texttt{voxel\_size}   & \SI{0,20}{\meter} \\ \hline
  \end{tabular}
  \caption{Startparameter des VoxelGrid-Filters}
  \label{tab:voxel_params}
\end{table}

\subsection{Ergebnis}
\label{subsec:ergebnis}

Wie in Abbildung~\ref{fig:voxel_compare} dargestellt, führt die Anwendung des
VoxelGrid-Filters zu einer gleichmäßigeren und deutlich reduzierten Punktdichte,
ohne dass dabei wichtige Strukturen der Szene verloren gehen.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{Bilder/voxel_compare.png}
  \caption{Vergleich nach \textit{CropBox} (links) und nach \textit{VoxelGrid-Filter} (rechts) (2025-10-15-Messdaten/2025-10-15-VK-OL-005)}
  \label{fig:voxel_compare}
\end{figure}

\section{Zusammenfassung}
Die implementierte Vorverarbeitung reduziert das Datenvolumen signifikant und schafft eine homogene Punktverteilung, ohne relevante geometrische Informationen zu verlieren. Durch die Kombination aus CropBox-Filter zur räumlichen Begrenzung und VoxelGrid-Filter zur Dichtehomogenisierung wird eine stabile und effiziente Basis für die nachfolgenden Schritte geschaffen.

Das so aufbereitete Datenmaterial wird im nächsten Kapitel der Bodensegmentierung zugeführt, um befahrbare Flächen von potenziellen Hindernissen zu trennen.